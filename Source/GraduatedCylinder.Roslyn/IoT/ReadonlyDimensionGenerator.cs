using System;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace GraduatedCylinder.Roslyn.IoT;

[Generator]
public class ReadonlyDimensionGenerator : BaseGenerator
{

    public ReadonlyDimensionGenerator()
        : base("GraduatedCylinder.IoT") { }

    protected override void ExecuteInternal(GeneratorExecutionContext context) {
        if (context.SyntaxReceiver is not DimensionReceiver receiver) {
            return;
        }
        //Debugger.Launch();

        foreach (StructDeclarationSyntax @struct in receiver.GetDimensions(context.Compilation)) {
            Log($"Generating for {@struct.Identifier}");
            GenerateFor(@struct).AddToContext(context);
        }
    }

    protected override void InitializeInternal(GeneratorInitializationContext context) {
        //Debugger.Launch();
        context.RegisterForSyntaxNotifications(() => new DimensionReceiver());
    }

    private GeneratedFile GenerateFor(StructDeclarationSyntax @struct) {
        WriteAutoGeneratedNotification();

        string format = @"using System;
using System.Runtime.InteropServices;
using GraduatedCylinder.Converters;

namespace GraduatedCylinder;

[StructLayout(LayoutKind.Sequential)]
public readonly partial struct {0} : IComparable<{0}>, IEquatable<{0}>
{{

    private readonly double _value;
    private readonly {0}Unit _units;

    public {0}(double value, {0}Unit units) {{
        _value = value;
        _units = units;
    }}

    public {0}Unit Units => _units;

    public double Value => _value;

    public int CompareTo({0} other) {{
        double thisValue, otherValue;
        if (Units == other.Units) {{
            thisValue = Value;
            otherValue = other.Value;
        }} else {{
            //should we always compare in base units?
            thisValue = {0}Converter.ToBase(this);
            otherValue = {0}Converter.ToBase(other);
        }}
        double delta = thisValue - otherValue;
        if (delta < 0) {{
            delta = -delta;
        }}
        if (delta < Equality.Tolerance) {{
            return 0;
        }}
        return thisValue > otherValue ? 1 : -1;
    }}

    public bool Equals({0} other) {{
        return CompareTo(other) == 0;
    }}

    public override bool Equals(object obj) {{
        return obj is {0} other && Equals(other);
    }}

    public override int GetHashCode() {{
        return (int)In({0}Unit.BaseUnit).Value.GetHashCode();
    }}

    public {0} In({0}Unit units) {{
        if ((Units == units) || (units == {0}Unit.Unspecified)) {{
            return this;
        }}
        double baseValue = {0}Converter.ToBase(this);
        return {0}Converter.FromBase(baseValue, units);
    }}

    public static {0} Zero {{ get; }} = new {0}(0, {0}Unit.BaseUnit);

    public static bool operator ==({0} left, {0} right) {{
        return left.CompareTo(right) == 0;
    }}

    public static bool operator >({0} left, {0} right) {{
        return left.CompareTo(right) > 0;
    }}

    public static bool operator >=({0} left, {0} right) {{
        return left.CompareTo(right) >= 0;
    }}

    public static bool operator !=({0} left, {0} right) {{
        return left.CompareTo(right) != 0;
    }}

    public static bool operator <({0} left, {0} right) {{
        return left.CompareTo(right) < 0;
    }}

    public static bool operator <=({0} left, {0} right) {{
        return left.CompareTo(right) <= 0;
    }}

    public static {0} operator +({0} left, {0} right) {{
        right = right.In(left.Units);
        return new {0}(left.Value + right.Value, left.Units);
    }}

    public static {0} operator -({0} left, {0} right) {{
        right = right.In(left.Units);
        return new {0}(left.Value - right.Value, left.Units);
    }}

    public static {0} operator -({0} source) {{
        return new {0}(-source.Value, source.Units);
    }}

    public static {0} operator *({0} left, double right) {{
        return new {0}(left.Value * right, left.Units);
    }}

    public static {0} operator *(double left, {0} right) {{
        return new {0}(left * right.Value, right.Units);
    }}

    public static {0} operator /({0} left, double right) {{
        return new {0}(left.Value / right, left.Units);
    }}

    public static double operator /({0} left, {0} right) {{
        right = right.In(left.Units);
        return left.Value / right.Value;
    }}

}}";
        Buffer.AppendFormat(format, @struct.Identifier, DateTime.Now);
        return BufferToGeneratedFile($"{@struct.Identifier}.g.cs");
    }

}