using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace GraduatedCylinder.Roslyn.Both;

[Generator]
public class ShortNamesGenerator : BaseGenerator
{

    public ShortNamesGenerator()
        : base("GraduatedCylinder", "GraduatedCylinder.IoT") { }

    protected override void ExecuteInternal(GeneratorExecutionContext context) {
        if (context.SyntaxReceiver is not UnitReceiver receiver) {
            return;
        }
        //Debugger.Launch();

        bool isIoT = context.Compilation.AssemblyName == "GraduatedCylinder.IoT";
        if (isIoT) {
            if (!SetExternalGenerationPath(context)) {
                return;
            }
        }

        WriteAutoGeneratedNotification();

        Buffer.AppendLine("using System;");
        Buffer.AppendLine();
        Buffer.AppendLine("namespace GraduatedCylinder.Text;");
        Buffer.AppendLine();
        Buffer.AppendLine("public static class ShortNames");
        Buffer.AppendLine("{");

        StringBuilder getAbbreviation = Buffer;
        StringBuilder getUnits = new();

        foreach (EnumDeclarationSyntax @enum in receiver.GetUnits(context.Compilation)) {
            Log($"Generating Abbreviations for {@enum.Identifier}");
            NameSet names = NameSet.FromUnitsType(@enum.Identifier.ToString());
            SemanticModel semanticModel = context.Compilation.GetSemanticModel(@enum.SyntaxTree);

            getAbbreviation.AppendLine();
            getAbbreviation.AppendLine($"\tpublic static string GetAbbreviation(this {names.UnitsTypeName} unit) {{");
            getAbbreviation.AppendLine("\t\tswitch (unit) {");

            getUnits.AppendLine();
            getUnits.AppendLine($"\tpublic static {names.UnitsTypeName} Get{names.UnitsTypeName}(string abbreviation) {{");
            getUnits.AppendLine("\t\tswitch (abbreviation) {");

            foreach (EnumMemberDeclarationSyntax enumMember in @enum.Members) {
                Log($"Processing: {names.UnitsTypeName}.{enumMember.Identifier}");
                ISymbol? enumValue = semanticModel.GetDeclaredSymbol(enumMember);
                AttributeData? attribute = enumValue?.GetAttributes()
                                                    .SingleOrDefault(a => a.AttributeClass?.ContainingNamespace.ToDisplayString() ==
                                                                          "GraduatedCylinder.Abbreviations");
                if (attribute is null) {
                    continue;
                }

                getAbbreviation.AppendLine($"\t\t\tcase {names.UnitsTypeName}.{enumMember.Identifier}:");
                getAbbreviation.AppendLine($"\t\t\t\treturn \"{attribute.ConstructorArguments[0].Value}\";");

                getUnits.AppendLine($"\t\t\tcase \"{attribute.ConstructorArguments[0].Value}\":");
                getUnits.AppendLine($"\t\t\t\treturn {names.UnitsTypeName}.{enumMember.Identifier};");
            }

            getAbbreviation.AppendLine("\t\t\tdefault:");
            getAbbreviation.AppendLine("\t\t\t\tthrow new Exception(\"Unknown unit type\");");
            getAbbreviation.AppendLine("\t\t}");
            getAbbreviation.AppendLine("\t}");

            getUnits.AppendLine("\t\t\tdefault:");
            getUnits.AppendLine("\t\t\t\tthrow new Exception(\"Unknown abbreviation\");");
            getUnits.AppendLine("\t\t}");
            getUnits.AppendLine("\t}");
        }
        Buffer.AppendLine(getUnits.ToString());
        Buffer.AppendLine();
        Buffer.AppendLine(@"}");

        if (isIoT) {
            BufferToGeneratedFile("Source\\GraduatedCylinder.IoT.Text\\ShortNames.g.cs").SaveToDisk();
        } else {
            BufferToGeneratedFile("ShortNames.g.cs").AddToContext(context);
        }
    }

    protected override void InitializeInternal(GeneratorInitializationContext context) {
        //Debugger.Launch();
        context.RegisterForSyntaxNotifications(() => new UnitReceiver());
    }

}