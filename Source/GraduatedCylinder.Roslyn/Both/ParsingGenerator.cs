using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace GraduatedCylinder.Roslyn.Both;

[Generator]
public class ParsingGenerator : BaseGenerator
{

    public ParsingGenerator()
        : base("GraduatedCylinder", "GraduatedCylinder.IoT") { }

    protected override void ExecuteInternal(GeneratorExecutionContext context) {
        if (context.SyntaxReceiver is not DimensionReceiver receiver) {
            return;
        }
        //Debugger.Launch();

        bool isIoT = context.Compilation.AssemblyName == "GraduatedCylinder.IoT";
        if (isIoT) {
            if (!SetExternalGenerationPath(context)) {
                return;
            }
        }

        //todo: implement all the parsers in a static class, then extend the type.
        List<StructDeclarationSyntax> structs = receiver.GetDimensions(context.Compilation).ToList();

        GenerateParserClass(isIoT, structs, context);
        if (!isIoT) {
            GenerateDimensionParseMethods(structs, context);
        }
    }

    protected override void InitializeInternal(GeneratorInitializationContext context) {
        context.RegisterForSyntaxNotifications(() => new DimensionReceiver());
    }

    private void GenerateDimensionParseMethods(List<StructDeclarationSyntax> structs, GeneratorExecutionContext context) {
        foreach (StructDeclarationSyntax @struct in structs) {
            Log($"Generating for {@struct.Identifier}");
            NameSet names = NameSet.FromDimensionType(@struct.Identifier.ToString());

            WriteAutoGeneratedNotification();

            Buffer.AppendLine("using System;");
            Buffer.AppendLine("using GraduatedCylinder.Text;");
            Buffer.AppendLine();
            Buffer.AppendLine("namespace GraduatedCylinder;");
            Buffer.AppendLine();
            Buffer.AppendLine($"public partial struct {names.DimensionTypeName}");
            Buffer.AppendLine("{");

            Buffer.AppendLine();
            Buffer.AppendLine($"\tpublic static {names.DimensionTypeName} Parse(string valueWithUnits) {{");
            Buffer.AppendLine($"\t\treturn Parser.Parse{names.DimensionTypeName}(valueWithUnits);");
            Buffer.AppendLine("\t}");

            Buffer.AppendLine();
            Buffer.AppendLine($"\tpublic static {names.DimensionTypeName} Parse(string value, {names.UnitsTypeName} units) {{");
            Buffer.AppendLine($"\t\treturn Parser.Parse{names.DimensionTypeName}(value, units);");
            Buffer.AppendLine("\t}");

            Buffer.AppendLine();
            Buffer.AppendLine("}");

            string filename = $"{names.DimensionTypeName}.Parse.g.cs";
            BufferToGeneratedFile(filename).AddToContext(context);
        }
    }

    private void GenerateParserClass(bool isIoT, List<StructDeclarationSyntax> structs, GeneratorExecutionContext context) {
        WriteAutoGeneratedNotification();

        Buffer.AppendLine("using System;");
        Buffer.AppendLine("using System.Text.RegularExpressions;");
        Buffer.AppendLine("");
        Buffer.AppendLine("namespace GraduatedCylinder.Text;");
        Buffer.AppendLine();
        Buffer.AppendLine("public static class Parser");
        Buffer.AppendLine("{");

        foreach (StructDeclarationSyntax @struct in structs) {
            Log($"Generating parser for {@struct.Identifier}");
            Buffer.AppendLine();
            Buffer.AppendLine($"\tpublic static {@struct.Identifier} Parse{@struct.Identifier}(string valueWithUnits) {{");
            Buffer.AppendLine("\t\tMatch match = Regexs.Pair.Match(valueWithUnits);");
            Buffer.AppendLine("\t\tif (match.Success) {");
            Buffer.AppendLine("\t\t\tif (double.TryParse(match.Groups[\"value\"].Value, out double doubleValue)) {");
            Buffer.AppendLine(
                $"\t\t\t\t{@struct.Identifier}Unit units = ShortNames.Get{@struct.Identifier}Unit(match.Groups[\"units\"].Value);");
            Buffer.AppendLine($"\t\t\t\treturn new {@struct.Identifier}(doubleValue, units);");
            Buffer.AppendLine("\t\t\t}");
            Buffer.AppendLine("\t\t}");
            Buffer.AppendLine("\t\tthrow new Exception($\"Error parsing: {valueWithUnits}\");");
            Buffer.AppendLine("\t}");

            Buffer.AppendLine();
            Buffer.AppendLine(
                $"\tpublic static {@struct.Identifier} Parse{@struct.Identifier}(string value, {@struct.Identifier}Unit units) {{");
            Buffer.AppendLine("\t\tMatch match = Regexs.ValueOnly.Match(value);");
            Buffer.AppendLine("\t\tif (match.Success) {");
            Buffer.AppendLine("\t\t\tif (double.TryParse(match.Groups[0].Value, out double doubleValue)) {");
            Buffer.AppendLine($"\t\t\t\treturn new {@struct.Identifier}(doubleValue, units);");
            Buffer.AppendLine("\t\t\t}");
            Buffer.AppendLine("\t\t}");
            Buffer.AppendLine("\t\tthrow new Exception($\"Error parsing: {value}\");");
            Buffer.AppendLine("\t}");
        }

        Buffer.AppendLine();
        Buffer.AppendLine("}");

        if (isIoT) {
            BufferToGeneratedFile("Source\\GraduatedCylinder.IoT.Text\\Parser.g.cs").SaveToDisk();
        } else {
            BufferToGeneratedFile("Parser.g.cs").AddToContext(context);
        }
    }

}